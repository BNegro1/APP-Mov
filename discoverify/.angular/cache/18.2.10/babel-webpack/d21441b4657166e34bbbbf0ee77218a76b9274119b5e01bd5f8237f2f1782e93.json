{"ast":null,"code":"import _asyncToGenerator from \"D:/Repositorios Oficial/Aplicacion-Movil/APP-Mov/discoverify/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { __decorate } from \"tslib\";\nimport { Injectable } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\nlet AuthService = class AuthService {\n  constructor(sqlite, platform) {\n    this.sqlite = sqlite;\n    this.platform = platform;\n    // Claves para almacenar el token de autenticación y el nombre de usuario en SQLite\n    this.AUTH_TOKEN_KEY = 'tokenAuth';\n    this.NOMBRE_USUARIO_KEY = 'username';\n    // Estado de autenticación observable\n    this.authenticationState = new BehaviorSubject(false);\n    // Inicializar la base de datos y actualizar el estado de autenticación\n    this.initDatabase();\n  }\n  // Inicializa la base de datos\n  initDatabase() {\n    this.platform.ready().then(() => {\n      this.sqlite.create({\n        name: 'auth.db',\n        location: 'default'\n      }).then(db => {\n        this.database = db;\n        this.createAuthTable();\n      }).catch(e => console.error('Error al crear la base de datos:', e));\n    });\n  }\n  // Crea la tabla de autenticación si no existe\n  createAuthTable() {\n    const query = `\n      CREATE TABLE IF NOT EXISTS auth (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        token TEXT,\n        nombreUsuario TEXT\n      );\n    `;\n    this.database.executeSql(query, []).then(() => {\n      this.updateAuthenticationState();\n    }).catch(e => console.error('Error al crear la tabla de autenticación:', e));\n  }\n  // Actualiza el estado de autenticación basado en la existencia del token\n  updateAuthenticationState() {\n    this.isTokenStored().then(tokenExists => {\n      this.setAuthenticationState(tokenExists);\n    });\n  }\n  // Verifica si el token está almacenado.\n  // Este método es privado porque solo se utiliza internamente para actualizar el estado de autenticación.\n  isTokenStored() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const query = 'SELECT token FROM auth LIMIT 1';\n      const res = yield _this.database.executeSql(query, []);\n      return res.rows.length > 0;\n    })();\n  }\n  // Establece el estado de autenticación !!! \n  // Se hace de la siguietne forma:\n  // 1. Se crea un método privado setAuthenticationState que recibe un booleano isAuthenticated y actualiza el valor del BehaviorSubject authenticationState.\n  // 2. Se llama a este método desde los métodos login y logout para actualizar el estado de autenticación.\n  setAuthenticationState(isAuthenticated) {\n    this.authenticationState.next(isAuthenticated);\n  }\n  // Inicia sesión almacenando las credenciales y actualizando el estado de autenticación\n  login(token, nombreUsuario) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      yield _this2.storeCredentials(token, nombreUsuario);\n      _this2.setAuthenticationState(true);\n    })();\n  }\n  // Almacena el token y el nombre de usuario\n  storeCredentials(token, nombreUsuario) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const query = 'INSERT INTO auth (token, nombreUsuario) VALUES (?, ?)';\n      yield _this3.database.executeSql(query, [token, nombreUsuario]);\n    })();\n  }\n  // Obtiene el nombre de usuario almacenado en SQLite\n  getNombreUsuario() {\n    return this.database.executeSql('SELECT nombreUsuario FROM auth LIMIT 1').then(res => res.rows.length > 0 ? res.rows.item(0).nombreUsuario : null);\n  }\n  // Verifica si el usuario está autenticado\n  isAuthenticated() {\n    return this.authenticationState.value;\n  }\n  // Cierra sesión eliminando las credenciales y actualizando el estado de autenticación\n  logout() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      yield _this4.clearCredentials();\n      _this4.setAuthenticationState(false);\n    })();\n  }\n  // Elimina el token y el nombre de usuario de SQLite\n  clearCredentials() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const query = 'DELETE FROM auth';\n      yield _this5.database.executeSql(query, []);\n    })();\n  }\n};\nAuthService = __decorate([Injectable({\n  providedIn: 'root'\n})\n// Se RE IMPLEMENTA auth.service.ts CON SQL LITE (otra vez)\n], AuthService);\nexport { AuthService };","map":{"version":3,"names":["Injectable","BehaviorSubject","AuthService","constructor","sqlite","platform","AUTH_TOKEN_KEY","NOMBRE_USUARIO_KEY","authenticationState","initDatabase","ready","then","create","name","location","db","database","createAuthTable","catch","e","console","error","query","executeSql","updateAuthenticationState","isTokenStored","tokenExists","setAuthenticationState","_this","_asyncToGenerator","res","rows","length","isAuthenticated","next","login","token","nombreUsuario","_this2","storeCredentials","_this3","getNombreUsuario","item","value","logout","_this4","clearCredentials","_this5","__decorate","providedIn"],"sources":["D:\\Repositorios Oficial\\Aplicacion-Movil\\APP-Mov\\discoverify\\src\\app\\services\\auth.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\nimport { SQLite, SQLiteObject } from '@awesome-cordova-plugins/sqlite/ngx';\nimport { Platform } from '@ionic/angular';\n\n@Injectable({\n  providedIn: 'root'\n})\n\n// Se RE IMPLEMENTA auth.service.ts CON SQL LITE (otra vez)\n\nexport class AuthService {\n  // Claves para almacenar el token de autenticación y el nombre de usuario en SQLite\n  private readonly AUTH_TOKEN_KEY = 'tokenAuth';\n  private readonly NOMBRE_USUARIO_KEY = 'username';\n  \n  private database!: SQLiteObject;\n\n  // Estado de autenticación observable\n  public authenticationState = new BehaviorSubject<boolean>(false);\n\n  constructor(private sqlite: SQLite, private platform: Platform) {\n    // Inicializar la base de datos y actualizar el estado de autenticación\n    this.initDatabase();\n  }\n\n  // Inicializa la base de datos\n  private initDatabase(): void {\n    this.platform.ready().then(() => {\n      this.sqlite.create({\n        name: 'auth.db',\n        location: 'default'\n      }).then((db: SQLiteObject) => {\n        this.database = db;\n        this.createAuthTable();\n      }).catch(e => console.error('Error al crear la base de datos:', e));\n    });\n  }\n\n  // Crea la tabla de autenticación si no existe\n  private createAuthTable(): void {\n    const query = `\n      CREATE TABLE IF NOT EXISTS auth (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        token TEXT,\n        nombreUsuario TEXT\n      );\n    `;\n    this.database.executeSql(query, []).then(() => {\n      this.updateAuthenticationState();\n    }).catch(e => console.error('Error al crear la tabla de autenticación:', e));\n  }\n\n  // Actualiza el estado de autenticación basado en la existencia del token\n  private updateAuthenticationState(): void {\n    this.isTokenStored().then(tokenExists => {\n      this.setAuthenticationState(tokenExists);\n    });\n  }\n\n  // Verifica si el token está almacenado.\n  // Este método es privado porque solo se utiliza internamente para actualizar el estado de autenticación.\n  private async isTokenStored(): Promise<boolean> {\n    const query = 'SELECT token FROM auth LIMIT 1';\n    const res = await this.database.executeSql(query, []);\n    return res.rows.length > 0;\n  }\n\n  // Establece el estado de autenticación !!! \n  // Se hace de la siguietne forma:\n  // 1. Se crea un método privado setAuthenticationState que recibe un booleano isAuthenticated y actualiza el valor del BehaviorSubject authenticationState.\n  // 2. Se llama a este método desde los métodos login y logout para actualizar el estado de autenticación.\n  private setAuthenticationState(isAuthenticated: boolean): void {\n    this.authenticationState.next(isAuthenticated);\n  }\n\n  // Inicia sesión almacenando las credenciales y actualizando el estado de autenticación\n  public async login(token: string, nombreUsuario: string): Promise<void> {\n    await this.storeCredentials(token, nombreUsuario);\n    this.setAuthenticationState(true);\n  }\n\n  // Almacena el token y el nombre de usuario\n  private async storeCredentials(token: string, nombreUsuario: string): Promise<void> {\n    const query = 'INSERT INTO auth (token, nombreUsuario) VALUES (?, ?)';\n    await this.database.executeSql(query, [token, nombreUsuario]);\n  }\n\n  // Obtiene el nombre de usuario almacenado en SQLite\n  public getNombreUsuario(): Promise<string | null> {\n    return this.database.executeSql('SELECT nombreUsuario FROM auth LIMIT 1')\n      .then(res => res.rows.length > 0 ? res.rows.item(0).nombreUsuario : null);\n  }\n\n\n  // Verifica si el usuario está autenticado\n  public isAuthenticated(): boolean {\n    return this.authenticationState.value;\n  }\n\n  // Cierra sesión eliminando las credenciales y actualizando el estado de autenticación\n  public async logout(): Promise<void> {\n    await this.clearCredentials();\n    this.setAuthenticationState(false);\n  }\n\n  // Elimina el token y el nombre de usuario de SQLite\n  private async clearCredentials(): Promise<void> {\n    const query = 'DELETE FROM auth';\n    await this.database.executeSql(query, []);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}